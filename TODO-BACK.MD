# TODO - Backend

### üîß 10. ENUM PATTERNS - Padr√µes para Uso de Enums

> **üìö Documenta√ß√£o Completa de Padr√µes para Enums**
>
> Baseado na implementa√ß√£o de **InvoiceStatus** e outros Enums do sistema
>
> ‚úÖ **OBRIGAT√ìRIO:** Todos os novos Enums devem seguir estes padr√µes
>
> üéØ **Objetivo:** Consist√™ncia, seguran√ßa de tipos e manutenibilidade

### üìã √çndice R√°pido

1. [Estrutura B√°sica de Enum](#-estrutura-b√°sica-de-enum)
2. [M√©todos √öteis em Enums](#-m√©todos-√∫teis-em-enums)
3. [Uso em Controllers](#-uso-em-controllers)
4. [Uso em Views](#-uso-em-views)
5. [Valida√ß√£o com Enums](#-valida√ß√£o-com-enums)
6. [Case Sensitivity](#-case-sensitivity)
7. [Exemplos Pr√°ticos](#-exemplos-pr√°ticos)
8. [Padr√£o de Filtragem de Data](#-11-date-filtering-patterns---padr√£o-de-filtragem-de-data)
9. [Gera√ß√£o de C√≥digos √önicos](#-12-unique-code-generation-patterns)

---

### üÜî 12. UNIQUE CODE GENERATION PATTERNS

Para m√≥dulos que exigem c√≥digos sequenciais √∫nicos (Or√ßamentos, Servi√ßos), utilizamos o padr√£o de rein√≠cio mensal com 6 d√≠gitos sequenciais para garantir escalabilidade e organiza√ß√£o.

#### Padr√£o de Formato:
`PREFIX-YYYY-MM-000000`

- **PREFIX:** 3 ou 4 letras identificadoras (ex: `ORC`, `SERV`)
- **YYYY:** Ano com 4 d√≠gitos
- **MM:** M√™s com 2 d√≠gitos
- **000000:** Sequencial de 6 d√≠gitos (reinicia a cada m√™s)

#### Exemplo de Implementa√ß√£o no Repository:
```php
public function generateUniqueCode(): string
{
    $year = date('Y');
    $month = date('m');
    $lastRecord = $this->getLastByMonth($year, $month);
    
    $sequential = 1;
    if ($lastRecord) {
        $sequential = $this->extractSequentialNumber($lastRecord->code) + 1;
    }
    
    return sprintf('PREFIX-%s-%s-%06d', $year, $month, $sequential);
}
```

#### Regras Importantes:
- **Tenant Isolation:** A busca pelo √∫ltimo registro deve sempre respeitar o `tenant_id`.
- **Monthly Reset:** O contador deve reiniciar em 1 no primeiro dia de cada m√™s.
- **Scalability:** O uso de 6 d√≠gitos permite at√© 999.999 registros por m√™s por empresa.
- **Concurrency:** Em cen√°rios de alta concorr√™ncia, utilizar `GET_LOCK()` do banco de dados para evitar duplicidade.

### üèóÔ∏è Estrutura B√°sica de Enum

```php
<?php

namespace App\Enums;

enum InvoiceStatus: string
{
    case PENDING = 'pending';
    case PAID = 'paid';
    case CANCELLED = 'cancelled';
    case OVERDUE = 'overdue';
    case PARTIAL = 'partial';

    // M√©todos √∫teis ser√£o adicionados aqui
}
```

**Boas Pr√°ticas:**

-  ‚úÖ Usar **UPPER_CASE** para nomes de casos
-  ‚úÖ Usar **lowercase** para valores (backing values)
-  ‚úÖ Sempre definir tipo de backing (string, int)
-  ‚úÖ Manter consist√™ncia com valores no banco de dados
-  ‚ùå Evitar espa√ßos ou caracteres especiais nos valores

---

### üîß M√©todos √öteis em Enums

```php
// M√©todo para obter todos os valores
public static function values(): array
{
    return array_column(self::cases(), 'value');
}

// M√©todo para obter todas as op√ß√µes para selects
public static function options(): array
{
    return array_combine(self::values(), self::labels());
}

// M√©todo para obter labels leg√≠veis
public static function labels(): array
{
    return [
        self::PENDING->value => 'Pendente',
        self::PAID->value => 'Pago',
        self::CANCELLED->value => 'Cancelado',
        self::OVERDUE->value => 'Vencido',
        self::PARTIAL->value => 'Parcial',
    ];
}

// M√©todo para obter label de um valor espec√≠fico
public static function label(string $value): string
{
    return self::labels()[$value] ?? $value;
}

// M√©todo para verificar se um valor √© v√°lido
public static function isValid(string $value): bool
{
    return in_array($value, self::values());
}

// M√©todo para obter cor associada ao status
public static function color(string $value): string
{
    $colors = [
        self::PENDING->value => 'warning',
        self::PAID->value => 'success',
        self::CANCELLED->value => 'danger',
        self::OVERDUE->value => 'danger',
        self::PARTIAL->value => 'info',
    ];

    return $colors[$value] ?? 'secondary';
}

// M√©todo para obter √≠cone associado ao status
public static function icon(string $value): string
{
    $icons = [
        self::PENDING->value => 'bi-hourglass-split',
        self::PAID->value => 'bi-check-circle',
        self::CANCELLED->value => 'bi-x-circle',
        self::OVERDUE->value => 'bi-exclamation-triangle',
        self::PARTIAL->value => 'bi-cash-coin',
    ];

    return $icons[$value] ?? 'bi-question-circle';
}
```

---

### üéØ Uso em Controllers

```php
// No controller - Exemplo de uso seguro com Enums

public function updateStatus(Invoice $invoice, Request $request)
{
    $validated = $request->validate([
        'status' => ['required', 'string', Rule::in(InvoiceStatus::values())],
    ]);

    $status = InvoiceStatus::from($validated['status']);

    $invoice->update(['status' => $status]);

    return redirect()->back()->with('success', 'Status atualizado com sucesso!');
}

// Exemplo com ServiceResult
public function getInvoicesByStatus(string $status): ServiceResult
{
    if (!InvoiceStatus::isValid($status)) {
        return $this->error('Status inv√°lido', 400);
    }

    $invoices = Invoice::where('status', $status)
        ->where('tenant_id', tenant('id'))
        ->get();

    return $this->success($invoices);
}
```

---

### üõ°Ô∏è Valida√ß√£o com Enums

```php
// Em Form Requests
public function rules()
{
    return [
        'status' => ['required', 'string', Rule::in(InvoiceStatus::values())],
    ];
}

// Em controllers
$request->validate([
    'status' => ['required', 'string', Rule::in(InvoiceStatus::values())],
]);

// Valida√ß√£o manual
if (!InvoiceStatus::isValid($request->status)) {
    return back()->withErrors(['status' => 'Status inv√°lido']);
}
```

---

### üî§ Case Sensitivity

> **‚ö†Ô∏è IMPORTANTE:** PHP Enums s√£o **case-sensitive** para os valores (backing values)

```php
// ‚ùå Isso causar√° erro:
InvoiceStatus::from('PENDING'); // Erro! Valor deve ser 'pending'

// ‚úÖ Correto:
InvoiceStatus::from('pending'); // OK

// ‚úÖ Melhor pr√°tica: Sempre usar o Enum diretamente
$status = InvoiceStatus::PENDING; // Melhor abordagem
$value = $status->value; // 'pending'

// ‚úÖ Compara√ß√£o segura:
if ($invoice->status === InvoiceStatus::PENDING->value) {
    // Faz algo
}

// ‚úÖ Verifica√ß√£o de igualdade:
if (InvoiceStatus::isValid($someValue)) {
    $status = InvoiceStatus::from($someValue);
}
```

**Boas Pr√°ticas para Case Sensitivity:**

1. ‚úÖ **Sempre usar o Enum diretamente** quando poss√≠vel
2. ‚úÖ **Validar valores de entrada** antes de converter para Enum
3. ‚úÖ **Usar m√©todos helper** como `isValid()` para verificar valores
4. ‚úÖ **Manter consist√™ncia** entre valores no banco e no Enum
5. ‚ùå **Nunca assumir** que valores de entrada s√£o v√°lidos
6. ‚ùå **Evitar compara√ß√µes diretas** de strings sem valida√ß√£o

---

### üõ°Ô∏è 11. STATUS ENUM INTERFACE - Padroniza√ß√£o de Status

> **‚úÖ OBRIGAT√ìRIO:** Todo Enum de status (Budget, Service, Invoice, etc.) deve implementar a `StatusEnumInterface`.

#### Estrutura Recomendada
Utilize a trait `HasStatusEnumMethods` para implementar automaticamente os m√©todos da interface.

```php
namespace App\Enums;

use App\Contracts\Interfaces\StatusEnumInterface;
use App\Traits\Enums\HasStatusEnumMethods;

enum ServiceStatus: string implements StatusEnumInterface
{
    use HasStatusEnumMethods;

    case DRAFT = 'draft';
    // ... cases
}
```

#### Benef√≠cios
- **getOptions():** Retorna op√ß√µes prontas para o Select do Blade.
- **getMetadata():** Retorna cor, √≠cone e label para badges.
- **isFinished() / isActive():** Facilita l√≥gica de neg√≥cio (ex: n√£o editar se finalizado).

---

### üìÖ 12. DATE FILTERING & DTO PATTERNS - Normaliza√ß√£o de Datas

#### Normaliza√ß√£o no Controller (Filtros)
Datas vindas do Frontend (`DD/MM/AAAA`) devem ser convertidas para `Y-m-d` antes de consultas.

```php
use App\Helpers\DateHelper;

public function index(Request $request)
{
    $filters = $request->validate([
        'start_date' => 'nullable|string',
        'end_date' => 'nullable|string',
    ]);

    if (!empty($filters['start_date'])) {
        $filters['start_date'] = DateHelper::parseDate($filters['start_date']);
    }
    // ...
}
```

#### Normaliza√ß√£o no DTO
Use `DateHelper::toCarbon()` ou `DateHelper::parseDate()` no `fromRequest`.

```php
public static function fromRequest(array $data): self
{
    return new self(
        // Para campos Carbon no DTO
        due_date: DateHelper::toCarbon($data['due_date'] ?? null),
        
        // Para campos string (Y-m-d) no DTO
        birth_date: DateHelper::parseDate($data['birth_date'] ?? null),
    );
}
```
protected function applyDateRangeFilter($query, $startDate, $endDate, $column = 'created_at')
{
    if ($startDate) {
        $query->where($column, '>=', Carbon::parse($startDate)->startOfDay());
    }
    if ($endDate) {
        $query->where($column, '<=', Carbon::parse($endDate)->endOfDay());
    }
}
```

#### Services e DTOs
- **Parsing:** Utilizar `DateHelper::parseBirthDate()` (ou similar) para converter strings vindas do frontend (`DD/MM/AAAA`) para o formato do banco (`Y-m-d`).
- **Valida√ß√£o:** Garantir que datas inv√°lidas n√£o quebrem a aplica√ß√£o, tratando exce√ß√µes de parsing no DTO ou Service.

#### Multi-tenancy
- **Isolamento:** Sempre garantir que filtros de data sejam aplicados *ap√≥s* ou *junto* com o isolamento de tenant (`tenant_id`), preferencialmente usando o trait `TenantScoped` no Model.

---

### üöÄ 12. CRUD PATTERNS - Padr√µes de CRUD (Ex: ServiceController)

#### Controllers
- **ServiceResult:** Sempre utilizar o padr√£o `ServiceResult` para retorno dos services.
- **Autoriza√ß√£o:** Utilizar `$this->authorize()` para validar permiss√µes via Policies.
- **Redirects:** Tratar sucessos e erros com mensagens de feedback amig√°veis (`with('success', ...)` ou `with('error', ...)`).
- **Index/Filtros:** Seguir o padr√£o de passagem de filtros para o Service/Repository.

Exemplo de Index:
```php
public function index(Request $request): View
{
    $this->authorize('viewAny', Service::class);
    
    $filters = $request->only(['search', 'category', 'active', 'start_date', 'end_date', 'deleted', 'per_page']);
    $result = $this->serviceService->getPaginated($filters);
    
    return view('pages.service.index', [
        'services' => $result->getData(),
        'filters' => $filters,
        'categories' => $this->categoryService->listParents()->getData(),
    ]);
}
```

Exemplo de Store:
```php
public function store(ServiceStoreRequest $request): RedirectResponse
{
    $this->authorize('create', Service::class);
    $dto = ServiceDTO::fromRequest($request->validated());
    $result = $this->serviceService->create($dto);

    if ($result->isError()) {
        return redirect()->back()->withInput()->with('error', $result->getMessage());
    }

    return redirect()->route('provider.services.show', $result->getData()->code)
        ->with('success', 'Criado com sucesso!');
}
```

#### Services
- **DTOs:** Utilizar DTOs para transfer√™ncia de dados entre Controller e Service.
- **Transa√ß√µes:** Utilizar `DB::transaction()` para garantir integridade em opera√ß√µes complexas.
- **Execu√ß√£o Segura:** Utilizar o m√©todo `safeExecute` (da `AbstractBaseService`) para capturar exce√ß√µes e retornar `ServiceResult`.

#### Repositories
- **Filtros de Data:** Utilizar `applyDateRangeFilter` da `RepositoryFiltersTrait`.
- **Tenant:** Garantir que todas as consultas respeitem o `tenant_id` (via `AbstractTenantRepository` ou Trait `TenantScoped`).

---

### ‚ö†Ô∏è Erros Comuns e Solu√ß√µes

#### Erro 1: Valor vazio para Enum

```php
// ‚ùå Causa erro:
$status = InvoiceStatus::from(''); // ValueError: "" is not a valid backing value

// ‚úÖ Solu√ß√£o:
if (!empty($value) && InvoiceStatus::isValid($value)) {
    $status = InvoiceStatus::from($value);
}
```

#### Erro 2: Case sensitivity

```php
// ‚ùå Causa erro:
$status = InvoiceStatus::from('PENDING'); // Erro! Deve ser 'pending'

// ‚úÖ Solu√ß√£o:
$status = InvoiceStatus::from(strtolower($input)); // Se necess√°rio converter
// Ou melhor:
$status = InvoiceStatus::PENDING; // Usar o Enum diretamente
```

#### Erro 3: Valor n√£o v√°lido

```php
// ‚ùå Causa erro:
$status = InvoiceStatus::from('invalid_status');

// ‚úÖ Solu√ß√£o:
if (InvoiceStatus::isValid($value)) {
    $status = InvoiceStatus::from($value);
} else {
    // Tratar erro ou usar valor padr√£o
    $status = InvoiceStatus::PENDING;
}
```

---

### üéØ Checklist para Uso de Enums

-  [ ] Definir Enum com backing type adequado (string/int)
-  [ ] Implementar m√©todos helper (values, options, labels, etc.)
-  [ ] Validar entradas de usu√°rio antes de converter para Enum
-  [ ] Usar Enum diretamente sempre que poss√≠vel
-  [ ] Implementar verifica√ß√µes de null/empty antes de usar
-  [ ] Documentar todos os casos de uso do Enum
-  [ ] Testar todos os valores do Enum
-  [ ] Manter consist√™ncia entre banco de dados e Enum

---

### üìö Refer√™ncia R√°pida

```php
// Obter todos os valores
InvoiceStatus::values();

// Obter op√ß√µes para select
InvoiceStatus::options();

// Obter label leg√≠vel
InvoiceStatus::label('pending'); // "Pendente"

// Verificar se valor √© v√°lido
InvoiceStatus::isValid('pending'); // true

// Obter cor para badge
InvoiceStatus::color('pending'); // "warning"

// Obter √≠cone
InvoiceStatus::icon('pending'); // "bi-hourglass-split"

// Usar Enum diretamente (melhor pr√°tica)
$status = InvoiceStatus::PENDING;
$value = $status->value; // "pending"
```

### üìÖ 11. DATE FILTERING PATTERN - Padr√£o de Filtro de Datas

Para garantir precis√£o em consultas de datas, especialmente em colunas `datetime` e `timestamp`, utilize sempre o intervalo completo do dia.

**No Service/Repository:**
```php
// ‚úÖ CORRETO: Utilizar intervalo completo (00:00:00 at√© 23:59:59)
if ($startDate) {
    $query->where('created_at', '>=', $startDate . ' 00:00:00');
}
if ($endDate) {
    $query->where('created_at', '<=', $endDate . ' 23:59:59');
}

// ‚ùå EVITAR: whereDate pode ser impreciso em alguns bancos ou ignorar componentes de tempo
$query->whereDate('created_at', '>=', $startDate);
```

**Normaliza√ß√£o de Datas (DateHelper):**
Sempre utilize o `DateHelper` para normalizar datas vindas do frontend (DD/MM/YYYY) para o formato do banco (YYYY-MM-DD).

```php
$startDate = DateHelper::parseBirthDate($filters['start_date'] ?? null);
```

---

### üìã Checklist de Implementa√ß√£o (Backend)
- [ ] Usar Service Layer e Actions.
- [ ] Tipagem estrita (`declare(strict_types=1)`).
- [ ] Tratamento de erros com `ServiceResult`.
- [ ] Filtros de data usando intervalo completo (00:00:00 - 23:59:59).
- [ ] Uso de DTOs para transfer√™ncia de dados complexos.

---

## üìä ESTAT√çSTICAS FINAIS

-  **Arquivos analisados:** 25+ arquivos de views
-  **Problemas identificados:** 15 inconsist√™ncias cr√≠ticas
-  **Arquivos corrigidos:** 15 arquivos principais
-  **Conformidade final:**
   -  Schedule: 98% ‚úÖ
   -  Reports: 98% ‚úÖ
   -  Modules: 98% ‚úÖ
   -  Admin Views: 95% ‚úÖ
-  **Relat√≥rios gerados:** 4 relat√≥rios detalhados
-  **Tempo investido:** 8+ horas de an√°lise e implementa√ß√£o

## üéØ RESULTADOS ALCAN√áADOS

### Conformidade de Padr√µes

-  **98% de conformidade** nos m√≥dulos principais (Schedule, Reports, Modules)
-  **95% de conformidade** nas views administrativas
-  **100% das URLs** convertidas para helpers Laravel
-  **100% da navega√ß√£o** funcionando corretamente

### Melhorias Implementadas

-  **Interface padronizada** em todos os m√≥dulos
-  **Responsividade completa** para dispositivos m√≥veis
-  **Performance otimizada** com pagina√ß√£o adequada
-  **UX consistente** em todo o sistema

### Documenta√ß√£o Produzida

-  **4 relat√≥rios detalhados** de an√°lise e corre√ß√µes
-  **TODO.md atualizado** com status do projeto
-  **Padr√µes documentados** para futuras implementa√ß√µes

---

---

## üë• Refatora√ß√£o do M√≥dulo de Clientes (CONCLU√çDO)

### Objetivo

Modernizar o m√≥dulo de clientes para utilizar os novos padr√µes arquiteturais do sistema: DTOs, ServiceResult, Service Layer e tipagem estrita.

### Tarefas Conclu√≠das

#### 1. Estrutura de DTOs
- [x] Criar `CustomerDTO` para transfer√™ncia de dados de cria√ß√£o e atualiza√ß√£o.
- [x] Criar `CustomerFilterDTO` para padronizar filtros de busca e listagem.
- [x] Criar `CustomerInteractionDTO` para registro de intera√ß√µes.
- [x] Criar `AddressDTO` e `ContactDTO` para sub-entidades.

#### 2. Service Layer
- [x] Refatorar `CustomerService` para usar DTOs e retornar `ServiceResult`.
- [x] Implementar `AddressService` e `ContactService` seguindo o padr√£o.
- [x] Integrar `CustomerInteractionService` com os novos padr√µes.
- [x] Implementar m√©todos de busca avan√ßada e estat√≠sticas no Service.

#### 3. Controllers
- [x] Refatorar `CustomerController` (Web) para usar DTOs e `ServiceResult`.
- [x] Refatorar `CustomerApiController` (API) para usar DTOs e `ServiceResult`.
- [x] Padronizar retornos JSON usando os helpers da classe base `Controller`.
- [x] Garantir que todas as permiss√µes sejam validadas via Policies.

#### 4. Repositories
- [x] Garantir que `CustomerRepository` suporte opera√ß√µes baseadas em DTO.
- [x] Validar isolamento de tenant em todas as consultas.
- [x] Implementar filtros de data padronizados.

---

## üîÑ Sistema de Reservas de Estoque (PENDENTE)

### Objetivo

Implementar sistema completo de reservas de estoque para controlar produtos reservados vs dispon√≠veis.

### Tarefas

#### 1. Estrutura de Banco de Dados

-  [ ] Criar migration para tabela `inventory_reservations`
   -  Campos: `id`, `tenant_id`, `product_id`, `quantity`, `reserved_by_type`, `reserved_by_id`, `status`, `expires_at`, `created_at`, `updated_at`
-  [ ] Adicionar campo `reserved_quantity` na tabela `inventories`
-  [ ] Criar √≠ndices para performance (product_id, tenant_id, status, expires_at)

#### 2. Models e Relacionamentos

-  [ ] Criar model `InventoryReservation`
-  [ ] Adicionar relacionamentos em `Product` e `Inventory`
-  [ ] Implementar scopes (active, expired, byProduct)

#### 3. L√≥gica de Neg√≥cio

-  [ ] Atualizar `InventoryService::reserveProduct()` com l√≥gica real
   -  Validar estoque dispon√≠vel (quantity - reserved_quantity)
   -  Criar registro em inventory_reservations
   -  Incrementar reserved_quantity
-  [ ] Atualizar `InventoryService::releaseReservation()` com l√≥gica real
   -  Marcar reserva como liberada
   -  Decrementar reserved_quantity
-  [ ] Criar m√©todo `InventoryService::getAvailableStock()` (quantity - reserved_quantity)

#### 4. Expira√ß√£o de Reservas

-  [ ] Criar job `ExpireInventoryReservations`
-  [ ] Agendar job no Kernel (rodar a cada hora)
-  [ ] Implementar l√≥gica de expira√ß√£o autom√°tica
-  [ ] Notificar quando reserva expirar

#### 5. Testes

-  [ ] Testes unit√°rios para InventoryService
-  [ ] Testes de integra√ß√£o para fluxo completo
-  [ ] Testes de expira√ß√£o de reservas

#### 6. Documenta√ß√£o

-  [ ] Documentar fluxo de reservas
-  [ ] Atualizar diagramas de banco de dados
-  [ ] Criar guia de uso para desenvolvedores

### Prioridade

**M√©dia** - Sistema funciona sem reservas reais, mas implementa√ß√£o futura melhora controle de estoque.

### Estimativa

**8-12 horas** de desenvolvimento + testes

---

## üìù NOTAS FINAIS

Retire os bot√µes "Exportar Todos" e "Atualizar" da tela de relat√≥rios. Esta interface funciona como ponto central de acesso aos relat√≥rios dos m√≥dulos, diferindo de outros √≠ndices. Priorize melhorias visuais mantendo os padr√µes do sistema.
