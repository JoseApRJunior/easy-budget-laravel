# TODO - Backend

### üîß 10. ENUM PATTERNS - Padr√µes para Uso de Enums

> **üìö Documenta√ß√£o Completa de Padr√µes para Enums**
>
> Baseado na implementa√ß√£o de **InvoiceStatus** e outros Enums do sistema
>
> ‚úÖ **OBRIGAT√ìRIO:** Todos os novos Enums devem seguir estes padr√µes
>
> üéØ **Objetivo:** Consist√™ncia, seguran√ßa de tipos e manutenibilidade

### üìã √çndice R√°pido

1. [Estrutura B√°sica de Enum](#-estrutura-b√°sica-de-enum)
2. [M√©todos √öteis em Enums](#-m√©todos-√∫teis-em-enums)
3. [Uso em Controllers](#-uso-em-controllers)
4. [Uso em Views](#-uso-em-views)
5. [Valida√ß√£o com Enums](#-valida√ß√£o-com-enums)
6. [Case Sensitivity](#-case-sensitivity)
7. [Exemplos Pr√°ticos](#-exemplos-pr√°ticos)
8. [Padr√£o de Filtragem de Data](#-11-date-filtering-patterns---padr√£o-de-filtragem-de-data)

---

### üèóÔ∏è Estrutura B√°sica de Enum

```php
<?php

namespace App\Enums;

enum InvoiceStatus: string
{
    case PENDING = 'pending';
    case PAID = 'paid';
    case CANCELLED = 'cancelled';
    case OVERDUE = 'overdue';
    case PARTIAL = 'partial';

    // M√©todos √∫teis ser√£o adicionados aqui
}
```

**Boas Pr√°ticas:**

-  ‚úÖ Usar **UPPER_CASE** para nomes de casos
-  ‚úÖ Usar **lowercase** para valores (backing values)
-  ‚úÖ Sempre definir tipo de backing (string, int)
-  ‚úÖ Manter consist√™ncia com valores no banco de dados
-  ‚ùå Evitar espa√ßos ou caracteres especiais nos valores

---

### üîß M√©todos √öteis em Enums

```php
// M√©todo para obter todos os valores
public static function values(): array
{
    return array_column(self::cases(), 'value');
}

// M√©todo para obter todas as op√ß√µes para selects
public static function options(): array
{
    return array_combine(self::values(), self::labels());
}

// M√©todo para obter labels leg√≠veis
public static function labels(): array
{
    return [
        self::PENDING->value => 'Pendente',
        self::PAID->value => 'Pago',
        self::CANCELLED->value => 'Cancelado',
        self::OVERDUE->value => 'Vencido',
        self::PARTIAL->value => 'Parcial',
    ];
}

// M√©todo para obter label de um valor espec√≠fico
public static function label(string $value): string
{
    return self::labels()[$value] ?? $value;
}

// M√©todo para verificar se um valor √© v√°lido
public static function isValid(string $value): bool
{
    return in_array($value, self::values());
}

// M√©todo para obter cor associada ao status
public static function color(string $value): string
{
    $colors = [
        self::PENDING->value => 'warning',
        self::PAID->value => 'success',
        self::CANCELLED->value => 'danger',
        self::OVERDUE->value => 'danger',
        self::PARTIAL->value => 'info',
    ];

    return $colors[$value] ?? 'secondary';
}

// M√©todo para obter √≠cone associado ao status
public static function icon(string $value): string
{
    $icons = [
        self::PENDING->value => 'bi-hourglass-split',
        self::PAID->value => 'bi-check-circle',
        self::CANCELLED->value => 'bi-x-circle',
        self::OVERDUE->value => 'bi-exclamation-triangle',
        self::PARTIAL->value => 'bi-cash-coin',
    ];

    return $icons[$value] ?? 'bi-question-circle';
}
```

---

### üéØ Uso em Controllers

```php
// No controller - Exemplo de uso seguro com Enums

public function updateStatus(Invoice $invoice, Request $request)
{
    $validated = $request->validate([
        'status' => ['required', 'string', Rule::in(InvoiceStatus::values())],
    ]);

    $status = InvoiceStatus::from($validated['status']);

    $invoice->update(['status' => $status]);

    return redirect()->back()->with('success', 'Status atualizado com sucesso!');
}

// Exemplo com ServiceResult
public function getInvoicesByStatus(string $status): ServiceResult
{
    if (!InvoiceStatus::isValid($status)) {
        return $this->error('Status inv√°lido', 400);
    }

    $invoices = Invoice::where('status', $status)
        ->where('tenant_id', tenant('id'))
        ->get();

    return $this->success($invoices);
}
```

---

### üõ°Ô∏è Valida√ß√£o com Enums

```php
// Em Form Requests
public function rules()
{
    return [
        'status' => ['required', 'string', Rule::in(InvoiceStatus::values())],
    ];
}

// Em controllers
$request->validate([
    'status' => ['required', 'string', Rule::in(InvoiceStatus::values())],
]);

// Valida√ß√£o manual
if (!InvoiceStatus::isValid($request->status)) {
    return back()->withErrors(['status' => 'Status inv√°lido']);
}
```

---

### üî§ Case Sensitivity

> **‚ö†Ô∏è IMPORTANTE:** PHP Enums s√£o **case-sensitive** para os valores (backing values)

```php
// ‚ùå Isso causar√° erro:
InvoiceStatus::from('PENDING'); // Erro! Valor deve ser 'pending'

// ‚úÖ Correto:
InvoiceStatus::from('pending'); // OK

// ‚úÖ Melhor pr√°tica: Sempre usar o Enum diretamente
$status = InvoiceStatus::PENDING; // Melhor abordagem
$value = $status->value; // 'pending'

// ‚úÖ Compara√ß√£o segura:
if ($invoice->status === InvoiceStatus::PENDING->value) {
    // Faz algo
}

// ‚úÖ Verifica√ß√£o de igualdade:
if (InvoiceStatus::isValid($someValue)) {
    $status = InvoiceStatus::from($someValue);
}
```

**Boas Pr√°ticas para Case Sensitivity:**

1. ‚úÖ **Sempre usar o Enum diretamente** quando poss√≠vel
2. ‚úÖ **Validar valores de entrada** antes de converter para Enum
3. ‚úÖ **Usar m√©todos helper** como `isValid()` para verificar valores
4. ‚úÖ **Manter consist√™ncia** entre valores no banco e no Enum
5. ‚ùå **Nunca assumir** que valores de entrada s√£o v√°lidos
6. ‚ùå **Evitar compara√ß√µes diretas** de strings sem valida√ß√£o

---

### üìã Exemplos Pr√°ticos

#### Exemplo 1: Filtro por Status

```php
// No controller
public function index(Request $request)
{
    $status = $request->input('status');

    if ($status && !InvoiceStatus::isValid($status)) {
        return back()->withErrors(['status' => 'Status inv√°lido']);
    }

    $query = Invoice::where('tenant_id', tenant('id'));

    if ($status) {
        $query->where('status', $status);
    }

    return view('invoices.index', ['invoices' => $query->paginate(15)]);
}
```

#### Exemplo 2: Atualiza√ß√£o de Status

```php
// No controller
public function updateStatus(Invoice $invoice, Request $request)
{
    $validated = $request->validate([
        'status' => ['required', 'string', Rule::in(InvoiceStatus::values())],
    ]);

    $status = InvoiceStatus::from($validated['status']);

    $invoice->update(['status' => $status->value]);

    return redirect()->back()->with('success', 'Status atualizado com sucesso!');
}
```

#### Exemplo 3: Verifica√ß√£o de Status

```php
// Em um service
public function canPay(Invoice $invoice): bool
{
    return $invoice->status === InvoiceStatus::PENDING->value
        || $invoice->status === InvoiceStatus::OVERDUE->value;
}

public function isPaid(Invoice $invoice): bool
{
    return $invoice->status === InvoiceStatus::PAID->value;
}
```

---

### üìÖ 11. DATE FILTERING PATTERNS - Padr√£o de Filtragem de Data

#### Reposit√≥rios e Traits
- **Precis√£o:** Sempre utilizar intervalos de tempo (datetime) em vez de `whereDate` para garantir consist√™ncia entre diferentes bancos de dados e precis√£o de segundos.
- **Intervalo:**
  - Data Inicial: `00:00:00`
  - Data Final: `23:59:59`
- **Trait:** Utilizar a `RepositoryFiltersTrait` com o m√©todo `applyDateRangeFilter`.

Exemplo na `RepositoryFiltersTrait`:
```php
protected function applyDateRangeFilter($query, $startDate, $endDate, $column = 'created_at')
{
    if ($startDate) {
        $query->where($column, '>=', Carbon::parse($startDate)->startOfDay());
    }
    if ($endDate) {
        $query->where($column, '<=', Carbon::parse($endDate)->endOfDay());
    }
}
```

#### Services e DTOs
- **Parsing:** Utilizar `DateHelper::parseBirthDate()` (ou similar) para converter strings vindas do frontend (`DD/MM/AAAA`) para o formato do banco (`Y-m-d`).
- **Valida√ß√£o:** Garantir que datas inv√°lidas n√£o quebrem a aplica√ß√£o, tratando exce√ß√µes de parsing no DTO ou Service.

#### Multi-tenancy
- **Isolamento:** Sempre garantir que filtros de data sejam aplicados *ap√≥s* ou *junto* com o isolamento de tenant (`tenant_id`), preferencialmente usando o trait `TenantScoped` no Model.

---

### üöÄ 12. CRUD PATTERNS - Padr√µes de CRUD (Ex: ServiceController)

#### Controllers
- **ServiceResult:** Sempre utilizar o padr√£o `ServiceResult` para retorno dos services.
- **Autoriza√ß√£o:** Utilizar `$this->authorize()` para validar permiss√µes via Policies.
- **Redirects:** Tratar sucessos e erros com mensagens de feedback amig√°veis (`with('success', ...)` ou `with('error', ...)`).
- **Index/Filtros:** Seguir o padr√£o de passagem de filtros para o Service/Repository.

Exemplo de Index:
```php
public function index(Request $request): View
{
    $this->authorize('viewAny', Service::class);
    
    $filters = $request->only(['search', 'category', 'active', 'start_date', 'end_date', 'deleted', 'per_page']);
    $result = $this->serviceService->getPaginated($filters);
    
    return view('pages.service.index', [
        'services' => $result->getData(),
        'filters' => $filters,
        'categories' => $this->categoryService->listParents()->getData(),
    ]);
}
```

Exemplo de Store:
```php
public function store(ServiceStoreRequest $request): RedirectResponse
{
    $this->authorize('create', Service::class);
    $dto = ServiceDTO::fromRequest($request->validated());
    $result = $this->serviceService->create($dto);

    if ($result->isError()) {
        return redirect()->back()->withInput()->with('error', $result->getMessage());
    }

    return redirect()->route('provider.services.show', $result->getData()->code)
        ->with('success', 'Criado com sucesso!');
}
```

#### Services
- **DTOs:** Utilizar DTOs para transfer√™ncia de dados entre Controller e Service.
- **Transa√ß√µes:** Utilizar `DB::transaction()` para garantir integridade em opera√ß√µes complexas.
- **Execu√ß√£o Segura:** Utilizar o m√©todo `safeExecute` (da `AbstractBaseService`) para capturar exce√ß√µes e retornar `ServiceResult`.

#### Repositories
- **Filtros de Data:** Utilizar `applyDateRangeFilter` da `RepositoryFiltersTrait`.
- **Tenant:** Garantir que todas as consultas respeitem o `tenant_id` (via `AbstractTenantRepository` ou Trait `TenantScoped`).

---

### ‚ö†Ô∏è Erros Comuns e Solu√ß√µes

#### Erro 1: Valor vazio para Enum

```php
// ‚ùå Causa erro:
$status = InvoiceStatus::from(''); // ValueError: "" is not a valid backing value

// ‚úÖ Solu√ß√£o:
if (!empty($value) && InvoiceStatus::isValid($value)) {
    $status = InvoiceStatus::from($value);
}
```

#### Erro 2: Case sensitivity

```php
// ‚ùå Causa erro:
$status = InvoiceStatus::from('PENDING'); // Erro! Deve ser 'pending'

// ‚úÖ Solu√ß√£o:
$status = InvoiceStatus::from(strtolower($input)); // Se necess√°rio converter
// Ou melhor:
$status = InvoiceStatus::PENDING; // Usar o Enum diretamente
```

#### Erro 3: Valor n√£o v√°lido

```php
// ‚ùå Causa erro:
$status = InvoiceStatus::from('invalid_status');

// ‚úÖ Solu√ß√£o:
if (InvoiceStatus::isValid($value)) {
    $status = InvoiceStatus::from($value);
} else {
    // Tratar erro ou usar valor padr√£o
    $status = InvoiceStatus::PENDING;
}
```

---

### üéØ Checklist para Uso de Enums

-  [ ] Definir Enum com backing type adequado (string/int)
-  [ ] Implementar m√©todos helper (values, options, labels, etc.)
-  [ ] Validar entradas de usu√°rio antes de converter para Enum
-  [ ] Usar Enum diretamente sempre que poss√≠vel
-  [ ] Implementar verifica√ß√µes de null/empty antes de usar
-  [ ] Documentar todos os casos de uso do Enum
-  [ ] Testar todos os valores do Enum
-  [ ] Manter consist√™ncia entre banco de dados e Enum

---

### üìö Refer√™ncia R√°pida

```php
// Obter todos os valores
InvoiceStatus::values();

// Obter op√ß√µes para select
InvoiceStatus::options();

// Obter label leg√≠vel
InvoiceStatus::label('pending'); // "Pendente"

// Verificar se valor √© v√°lido
InvoiceStatus::isValid('pending'); // true

// Obter cor para badge
InvoiceStatus::color('pending'); // "warning"

// Obter √≠cone
InvoiceStatus::icon('pending'); // "bi-hourglass-split"

// Usar Enum diretamente (melhor pr√°tica)
$status = InvoiceStatus::PENDING;
$value = $status->value; // "pending"
```

### üìÖ 11. DATE FILTERING PATTERN - Padr√£o de Filtro de Datas

Para garantir precis√£o em consultas de datas, especialmente em colunas `datetime` e `timestamp`, utilize sempre o intervalo completo do dia.

**No Service/Repository:**
```php
// ‚úÖ CORRETO: Utilizar intervalo completo (00:00:00 at√© 23:59:59)
if ($startDate) {
    $query->where('created_at', '>=', $startDate . ' 00:00:00');
}
if ($endDate) {
    $query->where('created_at', '<=', $endDate . ' 23:59:59');
}

// ‚ùå EVITAR: whereDate pode ser impreciso em alguns bancos ou ignorar componentes de tempo
$query->whereDate('created_at', '>=', $startDate);
```

**Normaliza√ß√£o de Datas (DateHelper):**
Sempre utilize o `DateHelper` para normalizar datas vindas do frontend (DD/MM/YYYY) para o formato do banco (YYYY-MM-DD).

```php
$startDate = DateHelper::parseBirthDate($filters['start_date'] ?? null);
```

---

### üìã Checklist de Implementa√ß√£o (Backend)
- [ ] Usar Service Layer e Actions.
- [ ] Tipagem estrita (`declare(strict_types=1)`).
- [ ] Tratamento de erros com `ServiceResult`.
- [ ] Filtros de data usando intervalo completo (00:00:00 - 23:59:59).
- [ ] Uso de DTOs para transfer√™ncia de dados complexos.

---

## üìä ESTAT√çSTICAS FINAIS

-  **Arquivos analisados:** 25+ arquivos de views
-  **Problemas identificados:** 15 inconsist√™ncias cr√≠ticas
-  **Arquivos corrigidos:** 15 arquivos principais
-  **Conformidade final:**
   -  Schedule: 98% ‚úÖ
   -  Reports: 98% ‚úÖ
   -  Modules: 98% ‚úÖ
   -  Admin Views: 95% ‚úÖ
-  **Relat√≥rios gerados:** 4 relat√≥rios detalhados
-  **Tempo investido:** 8+ horas de an√°lise e implementa√ß√£o

## üéØ RESULTADOS ALCAN√áADOS

### Conformidade de Padr√µes

-  **98% de conformidade** nos m√≥dulos principais (Schedule, Reports, Modules)
-  **95% de conformidade** nas views administrativas
-  **100% das URLs** convertidas para helpers Laravel
-  **100% da navega√ß√£o** funcionando corretamente

### Melhorias Implementadas

-  **Interface padronizada** em todos os m√≥dulos
-  **Responsividade completa** para dispositivos m√≥veis
-  **Performance otimizada** com pagina√ß√£o adequada
-  **UX consistente** em todo o sistema

### Documenta√ß√£o Produzida

-  **4 relat√≥rios detalhados** de an√°lise e corre√ß√µes
-  **TODO.md atualizado** com status do projeto
-  **Padr√µes documentados** para futuras implementa√ß√µes

---

## üîÑ Sistema de Reservas de Estoque (PENDENTE)

### Objetivo

Implementar sistema completo de reservas de estoque para controlar produtos reservados vs dispon√≠veis.

### Tarefas

#### 1. Estrutura de Banco de Dados

-  [ ] Criar migration para tabela `inventory_reservations`
   -  Campos: `id`, `tenant_id`, `product_id`, `quantity`, `reserved_by_type`, `reserved_by_id`, `status`, `expires_at`, `created_at`, `updated_at`
-  [ ] Adicionar campo `reserved_quantity` na tabela `inventories`
-  [ ] Criar √≠ndices para performance (product_id, tenant_id, status, expires_at)

#### 2. Models e Relacionamentos

-  [ ] Criar model `InventoryReservation`
-  [ ] Adicionar relacionamentos em `Product` e `Inventory`
-  [ ] Implementar scopes (active, expired, byProduct)

#### 3. L√≥gica de Neg√≥cio

-  [ ] Atualizar `InventoryService::reserveProduct()` com l√≥gica real
   -  Validar estoque dispon√≠vel (quantity - reserved_quantity)
   -  Criar registro em inventory_reservations
   -  Incrementar reserved_quantity
-  [ ] Atualizar `InventoryService::releaseReservation()` com l√≥gica real
   -  Marcar reserva como liberada
   -  Decrementar reserved_quantity
-  [ ] Criar m√©todo `InventoryService::getAvailableStock()` (quantity - reserved_quantity)

#### 4. Expira√ß√£o de Reservas

-  [ ] Criar job `ExpireInventoryReservations`
-  [ ] Agendar job no Kernel (rodar a cada hora)
-  [ ] Implementar l√≥gica de expira√ß√£o autom√°tica
-  [ ] Notificar quando reserva expirar

#### 5. Testes

-  [ ] Testes unit√°rios para InventoryService
-  [ ] Testes de integra√ß√£o para fluxo completo
-  [ ] Testes de expira√ß√£o de reservas

#### 6. Documenta√ß√£o

-  [ ] Documentar fluxo de reservas
-  [ ] Atualizar diagramas de banco de dados
-  [ ] Criar guia de uso para desenvolvedores

### Prioridade

**M√©dia** - Sistema funciona sem reservas reais, mas implementa√ß√£o futura melhora controle de estoque.

### Estimativa

**8-12 horas** de desenvolvimento + testes

---

## üìù NOTAS FINAIS

Retire os bot√µes "Exportar Todos" e "Atualizar" da tela de relat√≥rios. Esta interface funciona como ponto central de acesso aos relat√≥rios dos m√≥dulos, diferindo de outros √≠ndices. Priorize melhorias visuais mantendo os padr√µes do sistema.
