<?php

declare(strict_types=1);

namespace App\Console\Commands;

use App\Services\Infrastructure\MailerService;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

/**
 * Comando para gerenciamento avan√ßado da fila de emails.
 *
 * Permite visualizar estat√≠sticas, limpar filas, reenfileirar jobs falhos,
 * e outras opera√ß√µes administrativas espec√≠ficas para emails.
 */
class EmailQueueManage extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'email:manage
                            {action : A√ß√£o a executar (stats, clear, retry, flush, monitor)}
                            {--queue=emails : Nome da fila espec√≠fica}
                            {--hours=24 : Horas para an√°lise (usado em stats)}
                            {--force : For√ßa execu√ß√£o sem confirma√ß√£o}';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Manage email queue with advanced operations (stats, clear, retry, flush, monitor)';

    /**
     * Mailer service instance.
     */
    private MailerService $mailerService;

    /**
     * Create a new command instance.
     */
    public function __construct( MailerService $mailerService )
    {
        parent::__construct();
        $this->mailerService = $mailerService;
    }

    /**
     * Execute the console command.
     */
    public function handle(): int
    {
        $action = $this->argument( 'action' );
        $queue  = $this->option( 'queue' );

        $this->info( "üöÄ Gerenciando fila de emails: {$queue}" );
        $this->info( "üìã A√ß√£o solicitada: {$action}" );

        try {
            switch ( $action ) {
                case 'stats':
                    return $this->showQueueStats( $queue );

                case 'clear':
                    return $this->clearQueue( $queue );

                case 'retry':
                    return $this->retryFailedJobs( $queue );

                case 'flush':
                    return $this->flushQueue( $queue );

                case 'monitor':
                    return $this->monitorQueue( $queue );

                default:
                    $this->error( "‚ùå A√ß√£o '{$action}' n√£o reconhecida." );
                    $this->showAvailableActions();
                    return 1;
            }
        } catch ( \Throwable $e ) {
            Log::error( 'Erro no gerenciamento da fila de emails', [
                'action' => $action,
                'queue'  => $queue,
                'error'  => $e->getMessage(),
                'trace'  => $e->getTraceAsString()
            ] );

            $this->error( 'üí• Erro: ' . $e->getMessage() );
            return 1;
        }
    }

    /**
     * Exibe estat√≠sticas detalhadas da fila.
     */
    private function showQueueStats( string $queue ): int
    {
        $this->info( 'üìä Obtendo estat√≠sticas da fila...' );

        $stats = $this->mailerService->getEmailQueueStats();

        if ( isset( $stats[ 'error' ] ) ) {
            $this->error( '‚ùå ' . $stats[ 'error' ] );
            return 1;
        }

        $this->info( 'üìà Estat√≠sticas da fila de emails:' );
        $this->table(
            [ 'M√©trica', 'Valor' ],
            [
                [ 'Emails enfileirados', $stats[ 'queued_emails' ] ],
                [ 'Emails processando', $stats[ 'processing_emails' ] ],
                [ 'Emails com falha', $stats[ 'failed_emails' ] ],
                [ 'Jobs √∫ltima hora', $stats[ 'total_jobs_last_hour' ] ],
                [ 'Tempo m√©dio de espera', $stats[ 'avg_wait_time_seconds' ] . 's' ],
                [ 'Status da fila', $this->getStatusBadge( $stats[ 'queue_status' ] ) ],
                [ '√öltima atualiza√ß√£o', $stats[ 'timestamp' ] ],
            ],
        );

        // An√°lise adicional
        $this->analyzeQueueHealth( $stats );

        return 0;
    }

    /**
     * Limpa fila de emails (remove jobs pendentes).
     */
    private function clearQueue( string $queue ): int
    {
        if ( !$this->option( 'force' ) && !$this->confirm( 'Tem certeza que deseja limpar a fila de emails?', false ) ) {
            $this->info( 'Opera√ß√£o cancelada.' );
            return 0;
        }

        $this->info( 'üßπ Limpando fila de emails...' );

        $jobsTable = config( 'queue.connections.database.table', 'jobs' );
        $deleted   = DB::table( $jobsTable )
            ->where( 'queue', $queue )
            ->whereNull( 'reserved_at' )
            ->delete();

        $this->info( "‚úÖ {$deleted} jobs removidos da fila '{$queue}'." );

        Log::warning( 'Fila de emails limpa manualmente', [
            'queue'        => $queue,
            'jobs_removed' => $deleted,
            'user'         => auth()->id() ?? 'system'
        ] );

        return 0;
    }

    /**
     * Tenta reenfileirar jobs falhos.
     */
    private function retryFailedJobs( string $queue ): int
    {
        $this->info( 'üîÑ Tentando reenfileirar jobs falhos...' );

        $failedTable = config( 'queue.failed.table', 'failed_jobs' );
        $failedJobs  = DB::table( $failedTable )
            ->where( 'queue', $queue )
            ->get();

        if ( $failedJobs->isEmpty() ) {
            $this->info( '‚úÖ Nenhum job falho encontrado na fila.' );
            return 0;
        }

        $this->info( "üìã Encontrados {$failedJobs->count()} jobs falhos." );

        if ( !$this->option( 'force' ) && !$this->confirm( 'Deseja tentar reenfileirar esses jobs?', false ) ) {
            $this->info( 'Opera√ß√£o cancelada.' );
            return 0;
        }

        $retried = 0;
        foreach ( $failedJobs as $job ) {
            try {
                $this->retrySingleJob( $job );
                $retried++;
            } catch ( \Throwable $e ) {
                $this->error( "‚ùå Falha ao reenfileirar job {$job->id}: " . $e->getMessage() );
            }
        }

        $this->info( "‚úÖ {$retried} jobs reenfileirados com sucesso." );
        return 0;
    }

    /**
     * Esvazia completamente a fila (remove todos os jobs).
     */
    private function flushQueue( string $queue ): int
    {
        $this->warn( '‚ö†Ô∏è  Esta opera√ß√£o ir√° remover TODOS os jobs da fila!' );

        if ( !$this->option( 'force' ) && !$this->confirm( 'Tem certeza absoluta? Esta a√ß√£o n√£o pode ser desfeita!', false ) ) {
            $this->info( 'Opera√ß√£o cancelada.' );
            return 0;
        }

        $this->info( 'üí• Esvaziando fila de emails...' );

        $jobsTable = config( 'queue.connections.database.table', 'jobs' );
        $deleted   = DB::table( $jobsTable )
            ->where( 'queue', $queue )
            ->delete();

        $this->info( "‚úÖ {$deleted} jobs removidos completamente da fila '{$queue}'." );

        Log::critical( 'Fila de emails esvaziada completamente', [
            'queue'        => $queue,
            'jobs_removed' => $deleted,
            'user'         => auth()->id() ?? 'system'
        ] );

        return 0;
    }

    /**
     * Monitora a fila em tempo real.
     */
    private function monitorQueue( string $queue ): int
    {
        $this->info( 'üëÅÔ∏è  Iniciando monitoramento da fila de emails...' );
        $this->info( 'Pressione Ctrl+C para parar.' );

        $iterations = 0;
        while ( true ) {
            $stats = $this->mailerService->getEmailQueueStats();

            $this->showLiveStats( $stats, ++$iterations );

            sleep( 5 ); // Atualiza a cada 5 segundos
        }

        return 0;
    }

    /**
     * Exibe estat√≠sticas em tempo real.
     */
    private function showLiveStats( array $stats, int $iteration ): void
    {
        $this->newLine();
        $this->line( "üîÑ Monitoramento - Itera√ß√£o #{$iteration} - " . now()->format( 'H:i:s' ) );

        if ( isset( $stats[ 'error' ] ) ) {
            $this->error( '‚ùå Erro: ' . $stats[ 'error' ] );
            return;
        }

        $this->line( "üìä Enfileirados: {$stats[ 'queued_emails' ]} | Processando: {$stats[ 'processing_emails' ]} | Falhos: {$stats[ 'failed_emails' ]}" );
        $this->line( "‚è±Ô∏è  Tempo m√©dio de espera: {$stats[ 'avg_wait_time_seconds' ]}s" );
        $this->line( "üìà Status: " . $this->getStatusBadge( $stats[ 'queue_status' ] ) );
    }

    /**
     * Tenta reenfileirar um job individual.
     */
    private function retrySingleJob( object $job ): void
    {
        $jobsTable = config( 'queue.connections.database.table', 'jobs' );

        DB::table( $jobsTable )->insert( [
            'queue'        => $job->queue,
            'payload'      => $job->payload,
            'attempts'     => 0,
            'reserved_at'  => null,
            'available_at' => now()->timestamp,
            'created_at'   => now()->timestamp,
        ] );

        // Remove da tabela de falhas
        $failedTable = config( 'queue.failed.table', 'failed_jobs' );
        DB::table( $failedTable )->where( 'id', $job->id )->delete();

        Log::info( 'Job de email reenfileirado', [
            'failed_job_id' => $job->id,
            'queue'         => $job->queue
        ] );
    }

    /**
     * Analisa a sa√∫de da fila e d√° recomenda√ß√µes.
     */
    private function analyzeQueueHealth( array $stats ): void
    {
        $this->newLine();
        $this->info( 'üîç An√°lise de sa√∫de da fila:' );

        if ( $stats[ 'failed_emails' ] > 10 ) {
            $this->warn( '‚ö†Ô∏è  Muitos jobs falhos detectados! Considere verificar logs de erro.' );
        }

        if ( $stats[ 'queued_emails' ] > 50 ) {
            $this->warn( '‚ö†Ô∏è  Muitos emails enfileirados. Considere iniciar mais workers.' );
        }

        if ( $stats[ 'avg_wait_time_seconds' ] > 30 ) {
            $this->warn( '‚ö†Ô∏è  Tempo de espera alto. Workers podem estar sobrecarregados.' );
        }

        if ( $stats[ 'queue_status' ] === 'idle' && $stats[ 'queued_emails' ] === 0 ) {
            $this->info( '‚úÖ Fila saud√°vel e sem pend√™ncias.' );
        }
    }

    /**
     * Retorna badge colorido para status.
     */
    private function getStatusBadge( string $status ): string
    {
        return match ( $status ) {
            'active'   => '<fg=green>‚óè ATIVO</>',
            'idle'     => '<fg=blue>‚óè OCIOSO</>',
            'warning'  => '<fg=yellow>‚óè ATEN√á√ÉO</>',
            'critical' => '<fg=red>‚óè CR√çTICO</>',
            default    => '<fg=gray>‚óè DESCONHECIDO</>',
        };
    }

    /**
     * Exibe a√ß√µes dispon√≠veis.
     */
    private function showAvailableActions(): void
    {
        $this->info( 'A√ß√µes dispon√≠veis:' );
        $this->line( '  <fg=green>stats</>   - Exibir estat√≠sticas da fila' );
        $this->line( '  <fg=yellow>clear</>   - Limpar jobs pendentes' );
        $this->line( '  <fg=blue>retry</>   - Reenfileirar jobs falhos' );
        $this->line( '  <fg=red>flush</>   - Esvaziar fila completamente' );
        $this->line( '  <fg=cyan>monitor</> - Monitorar fila em tempo real' );
    }

}
