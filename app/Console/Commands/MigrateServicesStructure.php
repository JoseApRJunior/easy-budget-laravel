<?php

declare(strict_types=1);

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\File;
use Symfony\Component\Console\Helper\ProgressBar;

/**
 * Comando para migrar estrutura de servi√ßos para organiza√ß√£o por camadas.
 *
 * Este comando automatiza a reorganiza√ß√£o dos servi√ßos seguindo os princ√≠pios
 * de Clean Architecture e Domain-Driven Design.
 *
 * @author Kilo Code - Arquiteto de Software
 * @version 1.0.0
 */
class MigrateServicesStructure extends Command
{
    /**
     * The name and signature of the console command.
     */
    protected $signature = 'services:migrate-structure
                            {--dry-run : Executa em modo simula√ß√£o sem alterar arquivos}
                            {--backup : Cria backup dos arquivos antes da migra√ß√£o}
                            {--force : For√ßa execu√ß√£o mesmo com arquivos existentes}';

    /**
     * The console command description.
     */
    protected $description = 'Migra estrutura de servi√ßos para organiza√ß√£o por camadas (Domain, Application, Infrastructure)';

    /**
     * Estrutura de destino organizada por camadas.
     */
    private array $targetStructure = [
        'Domain'         => [
            'description' => 'Servi√ßos de Dom√≠nio (Model-based) - CRUD e regras de neg√≥cio',
            'services'    => [
                'ActivityService.php',
                'AddressService.php',
                'AuditService.php',
                'BudgetService.php',
                'CategoryService.php',
                'CommonDataService.php',
                'ContactService.php',
                'CustomerService.php',
                'InvoiceService.php',
                'PlanService.php',
                'ProductService.php',
                'ProviderService.php',
                'ReportService.php',
                'RoleService.php',
                'ServiceService.php',
                'SettingsService.php',
                'SupportService.php',
                'UserService.php',
            ]
        ],
        'Application'    => [
            'description' => 'Servi√ßos de Aplica√ß√£o (Business Logic) - Coordena√ß√£o complexa',
            'services'    => [
                'BudgetCalculationService.php',
                'BudgetPdfService.php',
                'BudgetStatusService.php',
                'BudgetTemplateService.php',
                'CustomerInteractionService.php',
                'EmailTemplateService.php',
                'EmailTrackingService.php',
                'ExportService.php',
                'FileUploadService.php',
                'InvoiceStatusService.php',
                'ProviderManagementService.php',
                'ServiceStatusService.php',
                'SettingsBackupService.php',
                'UserRegistrationService.php',
            ]
        ],
        'Infrastructure' => [
            'description' => 'Servi√ßos de Infraestrutura (External Services) - APIs e integra√ß√µes',
            'services'    => [
                'CacheService.php',
                'ChartService.php',
                'ChartVisualizationService.php',
                'EncryptionService.php',
                'FinancialSummary.php',
                'GeolocationService.php',
                'MailerService.php',
                'MercadoPagoService.php',
                'MerchantOrderMercadoPagoService.php',
                'MetricsService.php',
                'NotificationService.php',
                'PaymentMercadoPagoInvoiceService.php',
                'PaymentMercadoPagoPlanService.php',
                'PaymentService.php',
                'PdfService.php',
                'VariableProcessor.php',
                'WebhookService.php',
            ]
        ],
        'Core'           => [
            'description' => 'Arquitetura Core (Abstra√ß√µes) - Classes base e contratos',
            'services'    => [
                // Ser√° criado automaticamente - cont√©m Abstracts, Contracts, Traits
            ]
        ],
        'Shared'         => [
            'description' => 'Servi√ßos Compartilhados - Utilit√°rios comuns',
            'services'    => [
                // Ser√° criado automaticamente - servi√ßos que podem ser reutilizados
            ]
        ]
    ];

    /**
     * Regras de categoriza√ß√£o autom√°tica baseadas em padr√µes.
     */
    private array $autoCategorizationRules = [
        'Domain'         => [
            'patterns' => [ '*Service.php' ], // Padr√£o geral para servi√ßos
            'keywords' => [ 'Customer', 'Product', 'Budget', 'User', 'Role', 'Category', 'Audit', 'Activity' ],
            'exclude'  => [ 'Calculation', 'Pdf', 'Template', 'Status', 'Management', 'Tracking', 'Export', 'Upload', 'Backup' ]
        ],
        'Application'    => [
            'patterns' => [ '*CalculationService.php', '*PdfService.php', '*TemplateService.php', '*StatusService.php' ],
            'keywords' => [ 'Calculation', 'Pdf', 'Template', 'Status', 'Management', 'Tracking', 'Export', 'Upload', 'Backup', 'Registration', 'Interaction' ],
            'exclude'  => [ 'MercadoPago', 'Cache', 'Chart', 'Mail', 'Payment' ]
        ],
        'Infrastructure' => [
            'patterns' => [ '*MercadoPago*.php', '*Cache*.php', '*Chart*.php', '*Mail*.php', '*Payment*.php', '*Pdf*.php' ],
            'keywords' => [ 'MercadoPago', 'Cache', 'Chart', 'Mail', 'Payment', 'Pdf', 'Encryption', 'Geolocation', 'Metrics', 'Notification', 'VariableProcessor', 'Webhook' ],
            'exclude'  => []
        ]
    ];

    /**
     * Execute the console command.
     */
    public function handle(): int
    {
        $this->info( 'üèóÔ∏è  Migra√ß√£o de Estrutura de Servi√ßos - Easy Budget Laravel' );
        $this->info( '============================================================' );

        // Verificar modo de execu√ß√£o
        $isDryRun     = $this->option( 'dry-run' );
        $createBackup = $this->option( 'backup' );
        $force        = $this->option( 'force' );

        if ( $isDryRun ) {
            $this->warn( '‚ö†Ô∏è  MODO SIMULA√á√ÉO ATIVO - Nenhuma altera√ß√£o ser√° feita' );
        }

        if ( $createBackup && !$isDryRun ) {
            $this->info( 'üíæ Criando backup dos arquivos...' );
            $this->createBackup();
        }

        // Analisar servi√ßos atuais
        $currentServices = $this->analyzeCurrentServices();

        if ( empty( $currentServices ) ) {
            $this->error( '‚ùå Nenhum servi√ßo encontrado em app/Services/' );
            return 1;
        }

        $this->info( "üìä Encontrados {$currentServices[ 'count' ]} servi√ßos para migrar" );

        // Categorizar servi√ßos automaticamente
        $categorizedServices = $this->categorizeServicesAutomatically( $currentServices[ 'files' ] );

        // Mostrar plano de migra√ß√£o
        $this->displayMigrationPlan( $categorizedServices );

        if ( !$this->confirm( 'Deseja prosseguir com a migra√ß√£o?', !$isDryRun ) ) {
            $this->info( '‚úÖ Migra√ß√£o cancelada pelo usu√°rio' );
            return 0;
        }

        // Executar migra√ß√£o
        $results = $this->executeMigration( $categorizedServices, $isDryRun, $force );

        // Mostrar resultados
        $this->displayResults( $results );

        // Gerar relat√≥rio
        if ( !$isDryRun ) {
            $this->generateMigrationReport( $results );
        }

        return 0;
    }

    /**
     * Analisa servi√ßos atualmente na pasta app/Services/.
     */
    private function analyzeCurrentServices(): array
    {
        $servicesPath = app_path( 'Services' );
        $files        = File::files( $servicesPath );

        $serviceFiles = [];
        foreach ( $files as $file ) {
            if ( $file->getExtension() === 'php' && str_contains( $file->getFilename(), 'Service.php' ) ) {
                $serviceFiles[] = $file->getFilename();
            }
        }

        return [
            'path'  => $servicesPath,
            'files' => $serviceFiles,
            'count' => count( $serviceFiles )
        ];
    }

    /**
     * Categoriza servi√ßos automaticamente baseado em regras.
     */
    private function categorizeServicesAutomatically( array $serviceFiles ): array
    {
        $categorized = [];

        foreach ( $this->targetStructure as $layer => $config ) {
            $categorized[ $layer ] = [
                'services'         => [],
                'auto_categorized' => [],
                'manual_override'  => []
            ];
        }

        foreach ( $serviceFiles as $serviceFile ) {
            $categorizedService = $this->categorizeSingleService( $serviceFile );

            if ( $categorizedService ) {
                $categorized[ $categorizedService ][ 'services' ][]         = $serviceFile;
                $categorized[ $categorizedService ][ 'auto_categorized' ][] = $serviceFile;
            }
        }

        return $categorized;
    }

    /**
     * Categoriza um √∫nico servi√ßo baseado em regras autom√°ticas.
     */
    private function categorizeSingleService( string $serviceFile ): ?string
    {
        // Verificar regras espec√≠ficas primeiro
        foreach ( $this->autoCategorizationRules as $layer => $rules ) {
            // Verificar padr√µes
            foreach ( $rules[ 'patterns' ] as $pattern ) {
                if ( fnmatch( $pattern, $serviceFile ) ) {
                    // Verificar se n√£o est√° na lista de exclus√£o
                    $excluded = false;
                    foreach ( $rules[ 'exclude' ] as $exclude ) {
                        if ( str_contains( $serviceFile, $exclude ) ) {
                            $excluded = true;
                            break;
                        }
                    }
                    if ( !$excluded ) {
                        return $layer;
                    }
                }
            }

            // Verificar keywords
            foreach ( $rules[ 'keywords' ] as $keyword ) {
                if ( str_contains( $serviceFile, $keyword ) ) {
                    // Verificar se n√£o est√° na lista de exclus√£o
                    $excluded = false;
                    foreach ( $rules[ 'exclude' ] as $exclude ) {
                        if ( str_contains( $serviceFile, $exclude ) ) {
                            $excluded = true;
                            break;
                        }
                    }
                    if ( !$excluded ) {
                        return $layer;
                    }
                }
            }
        }

        // Fallback: tentar categorizar baseado no nome
        return $this->categorizeByName( $serviceFile );
    }

    /**
     * Categoriza baseado no nome do arquivo.
     */
    private function categorizeByName( string $serviceFile ): ?string
    {
        $name = strtolower( str_replace( 'Service.php', '', $serviceFile ) );

        // Padr√µes comuns para cada camada
        $domainPatterns         = [ 'customer', 'product', 'budget', 'user', 'role', 'category', 'audit', 'activity', 'address', 'contact', 'invoice', 'plan', 'provider', 'report', 'service', 'settings', 'support' ];
        $applicationPatterns    = [ 'calculation', 'template', 'status', 'management', 'tracking', 'export', 'upload', 'backup', 'registration', 'interaction' ];
        $infrastructurePatterns = [ 'mercadopago', 'cache', 'chart', 'mail', 'payment', 'pdf', 'encryption', 'geolocation', 'metrics', 'notification', 'variable', 'webhook' ];

        if ( $this->matchesAnyPattern( $name, $domainPatterns ) ) {
            return 'Domain';
        }

        if ( $this->matchesAnyPattern( $name, $applicationPatterns ) ) {
            return 'Application';
        }

        if ( $this->matchesAnyPattern( $name, $infrastructurePatterns ) ) {
            return 'Infrastructure';
        }

        // Se n√£o conseguir categorizar automaticamente, deixar para decis√£o manual
        return null;
    }

    /**
     * Verifica se string corresponde a algum padr√£o.
     */
    private function matchesAnyPattern( string $string, array $patterns ): bool
    {
        foreach ( $patterns as $pattern ) {
            if ( str_contains( $string, $pattern ) ) {
                return true;
            }
        }
        return false;
    }

    /**
     * Exibe plano de migra√ß√£o.
     */
    private function displayMigrationPlan( array $categorizedServices ): void
    {
        $this->info( "\nüìã PLANO DE MIGRA√á√ÉO:" );
        $this->info( "=====================" );

        foreach ( $categorizedServices as $layer => $data ) {
            if ( empty( $data[ 'services' ] ) ) {
                continue;
            }

            $this->info( "\nüèóÔ∏è  {$layer} ({$this->targetStructure[ $layer ][ 'description' ]})" );
            $this->info( "üìÇ Pasta: app/Services/{$layer}/" );

            foreach ( $data[ 'services' ] as $service ) {
                $this->line( "  ‚úÖ {$service}" );
            }
        }

        $totalServices = array_sum( array_map( fn( $data ) => count( $data[ 'services' ] ), $categorizedServices ) );
        $this->info( "\nüìä Total de servi√ßos a migrar: {$totalServices}" );
    }

    /**
     * Cria estrutura de pastas.
     */
    private function createDirectoryStructure(): void
    {
        $basePath = app_path( 'Services' );

        foreach ( array_keys( $this->targetStructure ) as $layer ) {
            $layerPath = "{$basePath}/{$layer}";
            if ( !File::exists( $layerPath ) ) {
                File::makeDirectory( $layerPath, 0755, true );
                $this->info( "üìÅ Criada pasta: {$layerPath}" );
            }
        }
    }

    /**
     * Executa a migra√ß√£o dos servi√ßos.
     */
    private function executeMigration( array $categorizedServices, bool $isDryRun, bool $force ): array
    {
        $results = [
            'moved'   => [],
            'errors'  => [],
            'skipped' => []
        ];

        if ( !$isDryRun ) {
            $this->createDirectoryStructure();
        }

        $totalSteps  = array_sum( array_map( fn( $data ) => count( $data[ 'services' ] ), $categorizedServices ) );
        $currentStep = 0;

        foreach ( $categorizedServices as $layer => $data ) {
            foreach ( $data[ 'services' ] as $serviceFile ) {
                $result = $this->migrateSingleService( $serviceFile, $layer, $isDryRun, $force );

                if ( $result[ 'success' ] ) {
                    $results[ 'moved' ][] = [
                        'service' => $serviceFile,
                        'from'    => 'app/Services/' . $serviceFile,
                        'to'      => "app/Services/{$layer}/{$serviceFile}",
                        'layer'   => $layer
                    ];
                } else {
                    $results[ 'errors' ][] = [
                        'service' => $serviceFile,
                        'error'   => $result[ 'error' ]
                    ];
                }

                $currentStep++;
                if ( $currentStep % 5 === 0 ) {
                    $this->output->write( '.' );
                }
            }
        }

        $this->newLine();
        $this->newLine();

        return $results;
    }

    /**
     * Migra um √∫nico servi√ßo.
     */
    private function migrateSingleService( string $serviceFile, string $layer, bool $isDryRun, bool $force ): array
    {
        $sourcePath = app_path( "Services/{$serviceFile}" );
        $targetPath = app_path( "Services/{$layer}/{$serviceFile}" );

        // Verificar se arquivo j√° existe no destino
        if ( File::exists( $targetPath ) && !$force ) {
            return [
                'success' => false,
                'error'   => "Arquivo j√° existe no destino: {$targetPath}"
            ];
        }

        if ( $isDryRun ) {
            return [ 'success' => true ];
        }

        try {
            // Mover arquivo
            File::move( $sourcePath, $targetPath );

            // Atualizar namespace no arquivo
            $this->updateNamespaceInFile( $targetPath, $layer );

            return [ 'success' => true ];
        } catch ( \Exception $e ) {
            return [
                'success' => false,
                'error'   => $e->getMessage()
            ];
        }
    }

    /**
     * Atualiza namespace no arquivo migrado.
     */
    private function updateNamespaceInFile( string $filePath, string $layer ): void
    {
        $content = File::get( $filePath );

        // Atualizar namespace
        $oldNamespace = 'namespace App\Services;';
        $newNamespace = "namespace App\Services\\{$layer};";

        $content = str_replace( $oldNamespace, $newNamespace, $content );

        // Atualizar imports de outras classes se necess√°rio
        $content = $this->updateImportsInFile( $content, $layer );

        File::put( $filePath, $content );
    }

    /**
     * Atualiza imports no conte√∫do do arquivo.
     */
    private function updateImportsInFile( string $content, string $layer ): string
    {
        // Imports que precisam ser ajustados
        $importAdjustments = [
            'App\Services\Abstracts' => "App\Services\\{$layer}\Abstracts",
            'App\Services\Contracts' => "App\Services\\{$layer}\Contracts",
            'App\Services\Traits'    => "App\Services\\{$layer}\Traits",
        ];

        foreach ( $importAdjustments as $oldImport => $newImport ) {
            $content = str_replace( $oldImport, $newImport, $content );
        }

        return $content;
    }

    /**
     * Cria backup dos arquivos.
     */
    private function createBackup(): void
    {
        $backupPath = storage_path( 'app/services-migration-backup-' . date( 'Y-m-d-H-i-s' ) );

        File::copyDirectory( app_path( 'Services' ), $backupPath );

        $this->info( "üíæ Backup criado em: {$backupPath}" );
    }

    /**
     * Exibe resultados da migra√ß√£o.
     */
    private function displayResults( array $results ): void
    {
        $this->info( "\nüìä RESULTADOS DA MIGRA√á√ÉO:" );
        $this->info( "==========================" );

        if ( !empty( $results[ 'moved' ] ) ) {
            $this->info( "‚úÖ Servi√ßos migrados com sucesso: " . count( $results[ 'moved' ] ) );
            foreach ( $results[ 'moved' ] as $moved ) {
                $this->line( "  üìÇ {$moved[ 'service' ]} ‚Üí {$moved[ 'layer' ]}/" );
            }
        }

        if ( !empty( $results[ 'errors' ] ) ) {
            $this->error( "‚ùå Erros durante migra√ß√£o: " . count( $results[ 'errors' ] ) );
            foreach ( $results[ 'errors' ] as $error ) {
                $this->line( "  ‚ö†Ô∏è  {$error[ 'service' ]}: {$error[ 'error' ]}" );
            }
        }

        if ( !empty( $results[ 'skipped' ] ) ) {
            $this->warn( "‚è≠Ô∏è  Servi√ßos pulados: " . count( $results[ 'skipped' ] ) );
            foreach ( $results[ 'skipped' ] as $skipped ) {
                $this->line( "  ‚è≠Ô∏è  {$skipped[ 'service' ]}: {$skipped[ 'reason' ]}" );
            }
        }
    }

    /**
     * Gera relat√≥rio da migra√ß√£o.
     */
    private function generateMigrationReport( array $results ): void
    {
        $reportPath = storage_path( 'app/services-migration-report-' . date( 'Y-m-d-H-i-s' ) . '.json' );

        $report = [
            'timestamp'      => date( 'Y-m-d H:i:s' ),
            'moved_services' => $results[ 'moved' ],
            'errors'         => $results[ 'errors' ],
            'skipped'        => $results[ 'skipped' ],
            'summary'        => [
                'total_moved'   => count( $results[ 'moved' ] ),
                'total_errors'  => count( $results[ 'errors' ] ),
                'total_skipped' => count( $results[ 'skipped' ] )
            ]
        ];

        File::put( $reportPath, json_encode( $report, JSON_PRETTY_PRINT ) );

        $this->info( "üìã Relat√≥rio gerado em: {$reportPath}" );
    }

}
